<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOS-Style Frequency Tracker</title>
    <style>
        /* Basic DOS-like styling */
        html, body {
            height: 100%; /* Ensure html and body take full height */
            margin: 0;
            overflow: hidden; /* Prevent body scrollbars */
        }
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #000080; /* Dark Blue */
            color: #C0C0C0; /* Light Gray */
            padding: 1em;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* height: 100vh; Removed, using 100% */
            box-sizing: border-box;
            user-select: none; /* Prevent accidental text selection outside cells */
        }

        h1 {
            margin-top: 0;
            margin-bottom: 0.5em;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .tracker-container {
            border: 2px solid #C0C0C0;
            padding: 5px;
            background-color: #000000; /* Black background for tracker */
            width: 98%; /* Adjusted width */
            max-width: 1000px; /* Increased max-width for more columns */
            overflow-y: auto; /* Allow scrolling within tracker if needed */
            flex-grow: 1; /* Allow tracker to take available space */
            margin-bottom: 1em;
            user-select: none; /* Prevent selection inside container */
            min-height: 0; /* **CSS Fix:** Helps prevent flex item overflow */
        }
         .tracker-container table {
             user-select: none; /* Prevent selection inside table */
         }
         /* Allow text selection ONLY in editable cells */
         .tracker-container td[contenteditable="true"] {
             user-select: text;
         }


        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed; /* Helps with column widths */
        }

        th, td {
            border: 1px solid #444444; /* Darker gray borders */
            padding: 2px 3px; /* Reduced padding slightly */
            text-align: center;
            height: 20px; /* Fixed row height */
            overflow: hidden; /* Prevent content spillover */
            white-space: nowrap; /* Prevent wrapping */
            font-size: 0.9em; /* Slightly smaller font */
            box-sizing: border-box; /* Include border in width/height */
        }

        th {
            background-color: #444444;
            color: #FFFFFF; /* White */
        }

        /* Column Widths */
        col.row-num { width: 4%; }
        col.tempo { width: 5%; }
        col.note { width: 8%; }
        col.inst { width: 4%; }
        col.vol { width: 4%; }
        col.fx { width: 4%; }
        col.separator { width: 1px; background-color: #666666; border: none;}


        /* Row numbers */
        td.row-num-cell {
            background-color: #222222;
            color: #888888;
            font-weight: bold;
            text-align: right;
            padding-right: 5px;
        }
        /* Focused Row Highlight (different from selection) */
         tr.focused-row > td.row-num-cell {
             background-color: #666600 !important;
             color: #FFFFFF !important;
         }


        /* Editable cells */
        .note-cell, .inst-cell, .vol-cell, .fx-cell, .tempo-cell {
            cursor: text;
            outline: none;
        }

        .tempo-cell { color: #FFA500; } /* Orange */
        .note-cell { color: #FFFF00; font-weight: bold; } /* Yellow */
        .inst-cell { color: #00FFFF; } /* Cyan */
        .vol-cell { color: #00FF00; } /* Green */
        .fx-cell { color: #FF00FF; } /* Magenta */

        /* Cell Focus (distinct from selection) */
        td:focus {
            background-color: #777777 !important; /* Darker gray focus */
            color: #FFFFFF !important;
            box-shadow: inset 0 0 0 1px #FFFFFF; /* White inner border on focus */
            z-index: 10; /* Ensure focus border is visible */
            position: relative; /* Needed for z-index */
        }

         /* Selection Highlight */
         td.selected-cell {
             background-color: #003366 !important; /* Dark blue selection */
             color: #FFFFFF !important; /* Ensure text is visible */
             box-shadow: inset 0 0 0 1px #0088FF; /* Blue inner border */
         }
         /* Ensure focus style overrides selection style for the active cell */
          td.selected-cell:focus {
             background-color: #225588 !important; /* Slightly lighter blue focus+selection */
             box-shadow: inset 0 0 0 1px #FFFFFF; /* White inner border on focus */
          }


        /* Playback highlight */
        .playing-row td {
            background-color: #004400 !important; /* Dark Green highlight */
            color: #FFFFFF !important; /* Default white text on highlight */
        }
        /* Keep original colors for data cells on playing row */
         .playing-row .tempo-cell { color: #FFA500 !important; }
         .playing-row .note-cell { color: #FFFF00 !important; }
         .playing-row .inst-cell { color: #00FFFF !important; }
         .playing-row .vol-cell { color: #00FF00 !important; }
         .playing-row .fx-cell { color: #FF00FF !important; }
         .playing-row .row-num-cell { color: #888888 !important; } /* Keep row number gray */
         /* Ensure playback highlight doesn't override selection/focus background */
         .playing-row td.selected-cell { background-color: #005533 !important; } /* Mix of green and blue */
         .playing-row td.selected-cell:focus { background-color: #227755 !important; }


        .controls {
            margin-top: auto; /* Push controls to bottom if space allows */
            padding-top: 10px; /* Add some space above buttons */
            padding-bottom: 5px; /* Space below buttons */
            text-align: center;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            flex-shrink: 0; /* Prevent shrinking */
        }

        button {
            font-family: 'Courier New', Courier, monospace;
            background-color: #C0C0C0;
            color: #000000;
            border: 2px outset #FFFFFF;
            padding: 5px 15px;
            cursor: pointer;
            font-weight: bold;
        }
         button:disabled {
             background-color: #888888; color: #444444; border-color: #aaaaaa; cursor: not-allowed;
         }
        button:active:not(:disabled) { border-style: inset; }

        .config-container, .capture-container {
             margin-top: 10px;
             margin-bottom: 5px;
             font-size: 0.9em;
             display: flex;
             flex-wrap: wrap;
             justify-content: center;
             gap: 15px; /* Spacing between items */
             width: 100%;
             max-width: 1000px; /* Match tracker width */
             flex-shrink: 0; /* Prevent shrinking */
        }
         .config-container label, .capture-container span {
             margin-right: 5px;
         }
         .config-container input[type="number"] {
             font-family: 'Courier New', Courier, monospace; background-color: #000000; color: #C0C0C0; border: 1px solid #C0C0C0; width: 50px; padding: 2px; text-align: center;
         }
         /* Style for captured value display */
         .capture-container {
             background-color: #000000;
             border: 1px solid #444444;
             padding: 5px 10px;
             color: #FFFF00; /* Yellow text for captured values */
         }
          .capture-container strong {
              color: #FFFFFF; /* White label */
          }


        #message-box {
            position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); background-color: #FFFF00; color: #000000; padding: 5px 10px; border: 1px solid #000000; font-size: 0.9em; display: none; z-index: 100; text-align: center;
        }

    </style>
</head>
<body>

    <h1>DOS-Style Frequency Tracker</h1>

    <div class="config-container">
        <div>
            <label for="base-freq">Base Freq (Hz):</label>
            <input type="number" id="base-freq" value="440" step="1">
        </div>
        <div>
            <label for="base-tempo">Base Tempo (BPM):</label>
            <input type="number" id="base-tempo" value="120" min="30" max="300" step="1">
        </div>
        <div>
            <label for="rows-per-beat">Rows/Beat:</label>
            <input type="number" id="rows-per-beat" value="4" min="1" max="16" step="1">
        </div>
    </div>

    <div class="capture-container">
        <span><strong>Captured Freq:</strong> <span id="captured-freq-display">440.00</span> Hz</span>
        <span><strong>Captured BPM:</strong> <span id="captured-tempo-display">120.0</span></span>
     </div>


    <div class="tracker-container" id="tracker-container">
        <table id="tracker-table">
             <colgroup>
                <col class="row-num">
                <col class="separator">
                <col class="tempo"> <col class="separator">
                <col class="note"> <col class="inst"> <col class="vol"> <col class="fx"> <col class="separator">
                <col class="note"> <col class="inst"> <col class="vol"> <col class="fx"> <col class="separator">
                <col class="note"> <col class="inst"> <col class="vol"> <col class="fx"> <col class="separator">
                <col class="note"> <col class="inst"> <col class="vol"> <col class="fx">
            </colgroup>
            <thead>
                <tr>
                    <th>Row</th> <th></th> <th>BPM</th> <th></th>
                    <th>Ch1 Note</th> <th>Inst</th> <th>Vol</th> <th>Fx</th> <th></th>
                    <th>Ch2 Note</th> <th>Inst</th> <th>Vol</th> <th>Fx</th> <th></th>
                    <th>Ch3 Note</th> <th>Inst</th> <th>Vol</th> <th>Fx</th> <th></th>
                    <th>Ch4 Note</th> <th>Inst</th> <th>Vol</th> <th>Fx</th>
                </tr>
            </thead>
            <tbody id="tracker-body">
                </tbody>
        </table>
    </div>

    <div class="controls">
        <button id="play-button">Play</button>
        <button id="stop-button">Stop</button>
        <button id="export-wav-button">Export WAV</button>
        <button id="export-json-button">Export JSON</button>
    </div>

    <div id="message-box"></div>

    <script>
        // --- Configuration ---
        const NUM_ROWS = 64; // Increased number of rows
        const NUM_CHANNELS = 4;
        const DEFAULT_VOLUME = 100;
        const DEFAULT_INSTRUMENT = 'sin';
        const INSTRUMENT_MAP = { 'sin': 'sine', 'sqr': 'square', 'saw': 'sawtooth', 'tri': 'triangle' };
        const VALID_INSTRUMENTS = Object.keys(INSTRUMENT_MAP);
        const EXPORT_SAMPLE_RATE = 44100;
        const EXPORT_BIT_DEPTH = 16;
        const COLUMN_TYPES = ['tempo', 'note', 'inst', 'vol', 'fx']; // Order for navigation

        // --- DOM References ---
        const BASE_FREQ_INPUT = document.getElementById('base-freq');
        const BASE_TEMPO_INPUT = document.getElementById('base-tempo');
        const ROWS_PER_BEAT_INPUT = document.getElementById('rows-per-beat');
        const TRACKER_BODY = document.getElementById('tracker-body');
        const TRACKER_CONTAINER = document.getElementById('tracker-container');
        const PLAY_BUTTON = document.getElementById('play-button');
        const STOP_BUTTON = document.getElementById('stop-button');
        const EXPORT_WAV_BUTTON = document.getElementById('export-wav-button');
        const EXPORT_JSON_BUTTON = document.getElementById('export-json-button');
        const MESSAGE_BOX = document.getElementById('message-box');
        const CAPTURED_FREQ_DISPLAY = document.getElementById('captured-freq-display');
        const CAPTURED_TEMPO_DISPLAY = document.getElementById('captured-tempo-display');


        // --- State Variables ---
        let audioContext = null;
        let masterGain = null;
        // Store nodes per channel: { osc, gain, lfo?, lfoGain? }
        let channelNodes = new Array(NUM_CHANNELS).fill(null);
        // Tracks {frequency, instrument} currently playing for phase continuity
        let channelPlayingData = new Array(NUM_CHANNELS).fill({ frequency: null, instrument: null });
        // Holds all pattern data: patternData[row][channel]
        let patternData = [];
        let isPlaying = false;
        let currentPlayRow = 0; // Row index for playback cursor
        let playbackIntervalId = null;
        let lastRowTime = 0; // For precise Web Audio scheduling
        // Captured values for ratio calculations
        let capturedFrequencyValue = parseFloat(BASE_FREQ_INPUT.value) || 440.0;
        let capturedTempoValue = parseFloat(BASE_TEMPO_INPUT.value) || 120.0;
        let currentlyEditingCell = null; // Reference to the cell being edited
        // Tracks cell focus position {row, track, type}
        let focusPos = { row: 0, track: 0, type: 'note' };
        // Tracks selection range {row, track, type}
        let selectionStartPos = null;
        let selectionEndPos = null;
        let isSelecting = false; // Currently unused, for potential mouse selection
        // Internal buffer for copy/paste
        let copiedSelectionData = null;

        // --- Audio Initialization ---
        function initAudio() { /* ... no change ... */ if(audioContext&&audioContext.state==='suspended'){audioContext.resume().catch(e=>console.error("Error resuming AudioContext:",e));return;}if(!audioContext){try{audioContext=new(window.AudioContext||window.webkitAudioContext)();masterGain=audioContext.createGain();masterGain.gain.setValueAtTime(0.5,audioContext.currentTime);masterGain.connect(audioContext.destination);console.log("AudioContext initialized.");}catch(e){console.error("Web Audio API not supported",e);showMessage("Error: Web Audio API not supported.");audioContext=null;}} }

        // --- Data Model Initialization ---
        function initializePatternData() { /* ... no change ... */ patternData=[];capturedFrequencyValue=parseFloat(BASE_FREQ_INPUT.value)||440.0;capturedTempoValue=parseFloat(BASE_TEMPO_INPUT.value)||120.0;updateCapturedValueDisplay();for(let r=0;r<NUM_ROWS;r++){const row=[];const tempoData={tempo:{inputString:"",value:null}};for(let c=0;c<NUM_CHANNELS;c++){const channelData={note:{inputString:"",frequency:null},instrument:DEFAULT_INSTRUMENT,instrumentInputString:"",volume:DEFAULT_VOLUME/100.0,volumeInputString:"",effect:{command:null,param1:null,param2:null,inputString:""}};row.push(c===0?{...channelData,...tempoData}:channelData);}patternData.push(row);}console.log("Pattern data initialized."); }

        // --- Get Effective Value (Handles Continuation) ---
        function getEffectiveValue(startRow, channel, type) { /* ... no change ... */ let value=null;let inputString="";let found=false;for(let r=startRow;r>=0;r--){const rowData=patternData[r];if(!rowData)continue;let data;if(type==='tempo'){data=rowData[0]?.tempo;if(data&&data.inputString){value=data.value;inputString=data.inputString;found=true;break;}}else{data=rowData[channel];if(!data)continue;switch(type){case'note':if(data.note&&data.note.inputString){value=data.note.frequency;inputString=data.note.inputString;found=true;}break;case'inst':if(data.instrumentInputString){value=data.instrument;inputString=data.instrumentInputString;found=true;}break;case'vol':if(data.volumeInputString){value=data.volume;inputString=data.volumeInputString;found=true;}break;case'fx':if(data.effect&&data.effect.inputString){value=data.effect;inputString=data.effect.inputString;found=true;}break;}if(found)break;}}if(!found){switch(type){case'tempo':value=parseFloat(BASE_TEMPO_INPUT.value)||120;break;case'note':value=null;break;case'inst':value=DEFAULT_INSTRUMENT;break;case'vol':value=DEFAULT_VOLUME/100.0;break;case'fx':value={command:null,param1:null,param2:null,inputString:""};break;}}if(type==='note'){return{frequency:value,inputString:inputString};}else if(type==='fx'){return value;}else{return value;}}

        // --- UI Generation & Updates ---
        function generateTrackerTable() { /* ... no change ... */ TRACKER_BODY.innerHTML='';for(let r=0;r<NUM_ROWS;r++){const tr=document.createElement('tr');tr.dataset.row=r;const tdRow=document.createElement('td');tdRow.textContent=r.toString().padStart(2,'0');tdRow.classList.add('row-num-cell');tr.appendChild(tdRow);tr.appendChild(createSeparatorCell());const tdTempo=createEditableCell(r,0,'tempo');tr.appendChild(tdTempo);tr.appendChild(createSeparatorCell());for(let c=0;c<NUM_CHANNELS;c++){tr.appendChild(createEditableCell(r,c,'note'));tr.appendChild(createEditableCell(r,c,'inst'));tr.appendChild(createEditableCell(r,c,'vol'));tr.appendChild(createEditableCell(r,c,'fx'));if(c<NUM_CHANNELS-1){tr.appendChild(createSeparatorCell());}}TRACKER_BODY.appendChild(tr);}updateFocusAndSelectionStyles();console.log("Tracker table generated."); }
        function createEditableCell(r, c, type) { /* ... no change ... */ const td=document.createElement('td');td.classList.add(`${type}-cell`);td.dataset.track=c;td.dataset.type=type;td.dataset.row=r;td.contentEditable=true;td.spellcheck=false;td.textContent=getCellDisplayValue(r,c,type);addCellEventListeners(td);return td; }
        function createSeparatorCell() { /* ... no change ... */ const td=document.createElement('td');td.classList.add('separator-cell');return td; }
        function addCellEventListeners(cellElement) { /* ... no change ... */ cellElement.addEventListener('focus',handleCellFocus);cellElement.addEventListener('blur',handleCellBlur);cellElement.addEventListener('keydown',handleCellKeyDown); }
        function updateFocusAndSelectionStyles() { /* ... no change ... */ document.querySelectorAll('.focused-row').forEach(el=>el.classList.remove('focused-row'));document.querySelectorAll('.selected-cell').forEach(el=>el.classList.remove('selected-cell'));const focusedRowEl=TRACKER_BODY.querySelector(`tr[data-row="${focusPos.row}"]`);if(focusedRowEl){focusedRowEl.classList.add('focused-row');}if(selectionStartPos&&selectionEndPos){const{minRow,maxRow,minColIdx,maxColIdx}=getSelectionBounds();if(!bounds)return;for(let r=minRow;r<=maxRow;r++){const cells=TRACKER_BODY.querySelectorAll(`tr[data-row="${r}"] td[contenteditable="true"]`);cells.forEach(cell=>{const cellColIdx=getCellOverallIndex(parseInt(cell.dataset.row),parseInt(cell.dataset.track),cell.dataset.type);if(cellColIdx>=minColIdx&&cellColIdx<=maxColIdx){cell.classList.add('selected-cell');}});}}}
        function getCellElement(row, track, type) { /* ... no change ... */ return TRACKER_BODY.querySelector(`tr[data-row="${row}"] td[data-track="${track}"][data-type="${type}"]`); }
        function getCellOverallIndex(row, track, type) { /* ... no change ... */ if(type==='tempo')return 0;const tI=COLUMN_TYPES.slice(1).indexOf(type);if(tI===-1)return -1;return 1+track*4+tI; }
        function getPosFromOverallIndex(rowIndex, overallIndex) { /* ... no change ... */ if(overallIndex===0)return{row:rowIndex,track:0,type:'tempo'};if(overallIndex<1)return null;const cI=Math.floor((overallIndex-1)/4);const tICI=(overallIndex-1)%4;if(cI>=NUM_CHANNELS)return null;const type=COLUMN_TYPES[1+tICI];return{row:rowIndex,track:cI,type:type}; }
        function getSelectionBounds() { /* ... no change ... */ if(!selectionStartPos||!selectionEndPos)return null;const sCI=getCellOverallIndex(selectionStartPos.row,selectionStartPos.track,selectionStartPos.type);const eCI=getCellOverallIndex(selectionEndPos.row,selectionEndPos.track,selectionEndPos.type);return{minRow:Math.min(selectionStartPos.row,selectionEndPos.row),maxRow:Math.max(selectionStartPos.row,selectionEndPos.row),minColIdx:Math.min(sCI,eCI),maxColIdx:Math.max(sCI,eCI)};}

        // --- Captured Value Display Update ---
        function updateCapturedValueDisplay() {
            CAPTURED_FREQ_DISPLAY.textContent = capturedFrequencyValue.toFixed(2);
            CAPTURED_TEMPO_DISPLAY.textContent = capturedTempoValue.toFixed(1);
        }

        // --- Input Handling ---
        function handleCellFocus(event) { /* ... no change ... */ currentlyEditingCell=event.target;focusPos={row:parseInt(currentlyEditingCell.dataset.row),track:parseInt(currentlyEditingCell.dataset.track),type:currentlyEditingCell.dataset.type};if(!event.shiftKey){selectionStartPos={...focusPos};selectionEndPos={...focusPos};isSelecting=false;}updateFocusAndSelectionStyles();setTimeout(()=>{if(document.activeElement===currentlyEditingCell){const s=window.getSelection();if(s&&typeof s.removeAllRanges==='function'&&typeof s.addRange==='function'){const r=document.createRange();r.selectNodeContents(currentlyEditingCell);s.removeAllRanges();s.addRange(r);}}},0); }

        function handleCellBlur(event) {
            // Finalize edit only if focus moves outside editable cells
             if (currentlyEditingCell === event.target) {
                 // Check if the new focus target (`relatedTarget`) exists and is NOT an editable cell within the table
                 // OR if relatedTarget is null (e.g., clicking outside the window/app)
                 if (!event.relatedTarget || !event.relatedTarget.closest || !event.relatedTarget.closest('#tracker-table td[contenteditable="true"]')) {
                     // console.log("Blur moving outside table, updating cell:", currentlyEditingCell.dataset.row, currentlyEditingCell.dataset.type);
                     updateCellData(currentlyEditingCell); // Save data
                 } else {
                     // console.log("Blur moving within table, not updating cell via blur.");
                 }
                 currentlyEditingCell = null; // Clear editing reference regardless
             }
        }

        function handleCellKeyDown(event) {
             const cell = event.target;
             const startPos = { ...focusPos };
             let handled = false;
             // **Important:** Get the stored input string *before* the keydown potentially changes the visual content
             const savedInputString = getCellDisplayValue(startPos.row, startPos.track, startPos.type, true);

             // --- Spacebar: Capture Value ---
             if (event.key === ' ') {
                 event.preventDefault(); handled = true;
                 if (focusPos.type === 'note') {
                     const effectiveNote = getEffectiveValue(focusPos.row, focusPos.track, 'note');
                     if (effectiveNote && effectiveNote.frequency !== null) { capturedFrequencyValue = effectiveNote.frequency; updateCapturedValueDisplay(); showMessage(`Captured Freq: ${capturedFrequencyValue.toFixed(2)} Hz`); flashCell(cell); } else { showMessage("No frequency to capture."); }
                 } else if (focusPos.type === 'tempo') {
                     const effectiveTempo = getEffectiveValue(focusPos.row, 0, 'tempo');
                     if (effectiveTempo !== null) { capturedTempoValue = effectiveTempo; updateCapturedValueDisplay(); showMessage(`Captured BPM: ${capturedTempoValue.toFixed(1)}`); flashCell(cell); } else { showMessage("No BPM to capture."); }
                 }
             }
             // --- Arrow Keys: Navigation & Selection ---
             else if (event.key.startsWith('Arrow')) {
                 event.preventDefault(); handled = true;

                 // **BUG FIX:** Check if visual content differs from last saved state *before* navigating
                 const currentText = cell.textContent.trim();
                 if (currentText !== savedInputString) {
                     console.log("Arrow key: Content changed, updating cell.");
                     updateCellData(cell); // Finalize edit if content changed before arrow press
                 } else {
                     console.log("Arrow key: Content unchanged, navigating only.");
                 }

                 // --- Navigation Logic ---
                 let nextPos = { ...focusPos };
                 const maxColIdx = getCellOverallIndex(0, NUM_CHANNELS - 1, 'fx');
                 if (event.key === 'ArrowUp') nextPos.row = (focusPos.row - 1 + NUM_ROWS) % NUM_ROWS;
                 else if (event.key === 'ArrowDown') nextPos.row = (focusPos.row + 1) % NUM_ROWS;
                 else if (event.key === 'ArrowLeft') { const cI=getCellOverallIndex(focusPos.row,focusPos.track,focusPos.type),nI=(cI-1+(maxColIdx+1))%(maxColIdx+1); nextPos=getPosFromOverallIndex(focusPos.row,nI); }
                 else if (event.key === 'ArrowRight') { const cI=getCellOverallIndex(focusPos.row,focusPos.track,focusPos.type),nI=(cI+1)%(maxColIdx+1); nextPos=getPosFromOverallIndex(focusPos.row,nI); }

                 const nextCell = getCellElement(nextPos.row, nextPos.track, nextPos.type);
                 if (nextCell) {
                     if (event.shiftKey) { selectionEndPos = { ...nextPos }; isSelecting = true; }
                     else { selectionStartPos = { ...nextPos }; selectionEndPos = { ...nextPos }; isSelecting = false; }
                     focusPos = { ...nextPos };
                     nextCell.focus(); // Move focus
                     updateFocusAndSelectionStyles();
                 }
             }
             // --- Enter Key: Finalize Edit & Move Down ---
             else if (event.key === 'Enter' && !event.shiftKey) {
                 event.preventDefault(); handled = true;
                 updateCellData(cell); // Finalize edit on Enter
                 let nextPos = { ...focusPos }; nextPos.row = (focusPos.row + 1) % NUM_ROWS;
                 const nextCell = getCellElement(nextPos.row, nextPos.track, nextPos.type);
                 if (nextCell) { selectionStartPos = { ...nextPos }; selectionEndPos = { ...nextPos }; focusPos = { ...nextPos }; nextCell.focus(); updateFocusAndSelectionStyles(); }
             }
             // --- Escape Key: Cancel Edit & Blur ---
             else if (event.key === 'Escape') {
                  event.preventDefault(); handled = true;
                  cell.textContent = getCellDisplayValue(focusPos.row, focusPos.track, focusPos.type); // Revert display to saved value
                  cell.blur(); // Remove focus
                  selectionStartPos = { ...focusPos }; selectionEndPos = { ...focusPos }; updateFocusAndSelectionStyles(); // Reset selection visual
             }
             // --- Delete/Backspace: Clear Selection --- (TODO)
             // --- Global keys (Ctrl+C/V/F5) handled by separate listener ---
        }

        // Helper function for visual feedback on capture
        function flashCell(cell) { /* ... no change ... */ cell.style.transition='background-color 0.1s ease-out';cell.style.backgroundColor='#FFFFFF';setTimeout(()=>{cell.style.backgroundColor='';cell.style.transition='';},100); }

        // --- Global Key Listener for Copy/Paste & F5 ---
        document.addEventListener('keydown', handleGlobalKeyDown);
        function handleGlobalKeyDown(event) {
             // --- F5: Start/Stop Playback ---
             if (event.key === 'F5') {
                 event.preventDefault(); // Prevent browser refresh
                 if (isPlaying) {
                     stopPlayback();
                 } else {
                     startPlayback();
                 }
                 return; // Don't process other keys if F5 was pressed
             }

             // --- Ctrl+C / Ctrl+V ---
             const isFocusInTracker = document.activeElement && document.activeElement.closest('#tracker-table td[contenteditable="true"]');
             const isFocusInInput = document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA');

             // Only handle C/V if focus is in the tracker and NOT in a config input
             if (!isFocusInTracker || isFocusInInput) return;

             if ((event.ctrlKey || event.metaKey) && event.key === 'c') {
                 event.preventDefault();
                 copySelectionToInternalBuffer();
             } else if ((event.ctrlKey || event.metaKey) && event.key === 'v') {
                  event.preventDefault();
                  pasteFromInternalBuffer();
             }
        }

        // --- Internal Copy/Paste Implementation ---
        function copySelectionToInternalBuffer() { /* ... no change ... */ if(!selectionStartPos||!selectionEndPos){showMessage("No selection to copy.");return;}const b=getSelectionBounds();if(!b)return;copiedSelectionData={start:{...selectionStartPos},rows:[]};for(let r=b.minRow;r<=b.maxRow;r++){const rD=[];for(let cI=b.minColIdx;cI<=b.maxColIdx;cI++){const p=getPosFromOverallIndex(r,cI);if(p){const dV=getCellDisplayValue(p.row,p.track,p.type,true);rD.push({track:p.track,type:p.type,value:dV});}else{rD.push(null);}}copiedSelectionData.rows.push(rD);}showMessage(`Copied ${copiedSelectionData.rows.length}x${copiedSelectionData.rows[0]?.length||0} block.`); }
        function pasteFromInternalBuffer() { /* ... no change ... */ if(!copiedSelectionData||!copiedSelectionData.rows.length){showMessage("Nothing in buffer to paste.");return;}const pSP={...focusPos};const sCI=getCellOverallIndex(pSP.row,pSP.track,pSP.type);let uR=new Set();copiedSelectionData.rows.forEach((rD,rO)=>{const tR=(pSP.row+rO);if(tR>=NUM_ROWS)return;rD.forEach((cD,cO)=>{if(!cD)return;const srcCI=getCellOverallIndex(0,cD.track,cD.type);const srcSCI=getCellOverallIndex(0,copiedSelectionData.start.track,copiedSelectionData.start.type);const rCO=srcCI-srcSCI;const tCI=sCI+rCO;const tP=getPosFromOverallIndex(tR,tCI);if(tP&&tP.row<NUM_ROWS){const tC=getCellElement(tP.row,tP.track,tP.type);if(tC){tC.textContent=cD.value;updateCellData(tC);uR.add(tP.row);}}});});showMessage(`Pasted block.`); }

        // Helper to get the display value (raw input string) for a cell
        function getCellDisplayValue(row, track, type, raw = true) { /* ... no change ... */ if(!patternData[row])return'';const data=patternData[row][track];if(!data)return'';switch(type){case'tempo':return patternData[row][0].tempo.inputString;case'note':return data.note.inputString;case'inst':return data.instrumentInputString||'';case'vol':return data.volumeInputString||'';case'fx':return data.effect.inputString||'';default:return'';}}

        // --- Update Cell Data (Core Logic - Refined Ratio Handling & FX Parsing) ---
        function updateCellData(cellElement) { /* ... No change needed here, logic was correct ... */ const row=parseInt(cellElement.dataset.row);const track=parseInt(cellElement.dataset.track);const type=cellElement.dataset.type;const inputText=cellElement.textContent.trim();if(row<0||row>=NUM_ROWS||track<0||track>=NUM_CHANNELS)return;let data=patternData[row][track];let isValid=true;let finalDisplayValue=inputText;switch(type){case'tempo':data=patternData[row][0];const eT=data.tempo.value;const tPR=parseTempoInput(inputText);data.tempo.inputString=inputText;if(tPR.type==='bpm'){data.tempo.value=tPR.value;if(data.tempo.value!==null){capturedTempoValue=data.tempo.value;updateCapturedValueDisplay();}else if(inputText){isValid=false;}}else if(tPR.type==='ratio'){const bT=(eT!==null&&eT>0)?eT:capturedTempoValue;if(bT>0){const cT=bT*tPR.num/tPR.den;if(cT>=30&&cT<=300){data.tempo.value=cT;finalDisplayValue=cT.toFixed(1);data.tempo.inputString=finalDisplayValue;capturedTempoValue=cT;updateCapturedValueDisplay();cellElement.textContent=finalDisplayValue;}else{isValid=false;data.tempo.value=null;}}else{isValid=false;data.tempo.value=null;}}else{data.tempo.value=null;if(inputText)isValid=false;}break;case'note':const eF=data.note.frequency;const nPR=parseNoteInput(inputText);data.note.inputString=inputText;if(nPR.type==='hz'){data.note.frequency=nPR.frequency;if(data.note.frequency!==null){capturedFrequencyValue=data.note.frequency;updateCapturedValueDisplay();}else if(inputText){isValid=false;}}else if(nPR.type==='ratio'){const bF=(eF!==null&&eF>0)?eF:capturedFrequencyValue;if(bF>0){const cF=bF*nPR.num/nPR.den;if(cF>0){data.note.frequency=cF;finalDisplayValue=cF.toFixed(2);data.note.inputString=finalDisplayValue;capturedFrequencyValue=cF;updateCapturedValueDisplay();cellElement.textContent=finalDisplayValue;}else{isValid=false;data.note.frequency=null;}}else{isValid=false;data.note.frequency=null;}}else{data.note.frequency=null;if(inputText)isValid=false;}break;case'inst':const cI=inputText.toLowerCase();data.instrumentInputString=inputText;if(VALID_INSTRUMENTS.includes(cI)){data.instrument=cI;}else if(!inputText){data.instrument=DEFAULT_INSTRUMENT;}else{isValid=false;}break;case'vol':const vI=parseInt(inputText,10);data.volumeInputString=inputText;if(!isNaN(vI)&&vI>=0&&vI<=100){data.volume=vI/100.0;}else if(!inputText){data.volume=DEFAULT_VOLUME/100.0;}else{isValid=false;}break;case'fx':data.effect.inputString=inputText;data.effect.command=null;data.effect.param1=null;data.effect.param2=null;if(inputText){const cmd=inputText.substring(0,1).toUpperCase();const pS=inputText.substring(1);const p=pS.split(';').map(p=>p.trim()).filter(p=>p!=='');if(cmd==='V'&&p.length>=2){const r=parseFloat(p[0]);const d=parseFloat(p[1]);if(!isNaN(r)&&r>0&&!isNaN(d)&&d>=0){data.effect.command='V';data.effect.param1=r;data.effect.param2=d;}else{isValid=false;}}else if(cmd&&pS){data.effect.command=cmd;data.effect.value=pS;}else if(cmd&&!pS){data.effect.command=cmd;}else{isValid=false;}}break;}if(!isValid&&inputText){cellElement.style.backgroundColor='#8B0000';setTimeout(()=>{cellElement.style.backgroundColor='';},500);}}

        // --- Input Parsing (Refined) ---
        function parseNoteInput(inputStr) { /* ... no change ... */ inputStr=inputStr.trim();if(!inputStr)return{type:'invalid'};if(/^\d+(\.\d+)?$/.test(inputStr)){const f=parseFloat(inputStr);return{type:'hz',frequency:f>0?f:null};}const rM=inputStr.match(/^(\d+)\s*:\s*(\d+)$/);if(rM){try{const n=parseInt(rM[1]),d=parseInt(rM[2]);if(d<=0||n<0)return{type:'invalid'};return{type:'ratio',num:n,den:d};}catch(e){return{type:'invalid'};}}return{type:'invalid'};}
        function parseTempoInput(inputStr) { /* ... no change ... */ inputStr=inputStr.trim();if(!inputStr)return{type:'invalid'};if(/^\d+(\.\d+)?$/.test(inputStr)){const b=parseFloat(inputStr);return{type:'bpm',value:(b>=30&&b<=300)?b:null};}const rM=inputStr.match(/^(\d+)\s*:\s*(\d+)$/);if(rM){try{const n=parseInt(rM[1]),d=parseInt(rM[2]);if(d<=0||n<0)return{type:'invalid'};return{type:'ratio',num:n,den:d};}catch(e){return{type:'invalid'};}}return{type:'invalid'};}


        // --- Realtime Playback Logic (Phase Continuity + Vibrato) ---
        function playStep() { /* ... no change ... */ if(!isPlaying||!audioContext)return;const eT=getEffectiveTempo(currentPlayRow);const tD=getTickDurationSeconds(eT);const cT=audioContext.currentTime;document.querySelectorAll('.playing-row').forEach(r=>r.classList.remove('playing-row'));const rE=TRACKER_BODY.querySelector(`tr[data-row="${currentPlayRow}"]`);if(rE){rE.classList.add('playing-row');const r=rE.getBoundingClientRect();const cR=TRACKER_CONTAINER.getBoundingClientRect();if(r.top<cR.top||r.bottom>cR.bottom)rE.scrollIntoView({behavior:'smooth',block:'nearest'});}for(let c=0;c<NUM_CHANNELS;c++){const nD=getEffectiveValue(currentPlayRow,c,'note');const i=getEffectiveValue(currentPlayRow,c,'inst');const v=getEffectiveValue(currentPlayRow,c,'vol');const effect=getEffectiveValue(currentPlayRow,c,'fx');const cF=(nD&&nD.frequency!==null)?nD.frequency:null;const cI=i||DEFAULT_INSTRUMENT;const wP=channelPlayingData[c];const iNC=(cF!==null&&cF===wP.frequency&&cI===wP.instrument);let needsStop=false;if(channelNodes[c]){if(cF===null){needsStop=true;}else if(!iNC){needsStop=true;}else{const currentCommand=effect?.command;const previousCommand=getEffectiveValue(currentPlayRow-1,c,'fx')?.command;if((currentCommand==='V'&&previousCommand!=='V')||(currentCommand!=='V'&&previousCommand==='V')){needsStop=true;}}}if(needsStop&&channelNodes[c]){stopChannelNodes(c,cT);}if(cF!==null&&cF>0&&v>0){if(!channelNodes[c]){playFrequency(c,cF,cI,v,effect,cT);channelPlayingData[c]={frequency:cF,instrument:cI};}else{/* TODO: Update effect params? */}}else{channelPlayingData[c]={frequency:null,instrument:null};}}currentPlayRow=(currentPlayRow+1)%NUM_ROWS;const nST=lastRowTime+tD;const delay=Math.max(0,nST-audioContext.currentTime);playbackIntervalId=setTimeout(playStep,delay*1000);lastRowTime=nST;}

        // Function to stop all audio nodes associated with a channel
        function stopChannelNodes(channelIndex, stopTime) { /* ... no change ... */ const nodes=channelNodes[channelIndex];if(!nodes||!audioContext)return;try{if(nodes.gain){nodes.gain.gain.cancelScheduledValues(stopTime);nodes.gain.gain.setValueAtTime(nodes.gain.gain.value,stopTime);nodes.gain.gain.linearRampToValueAtTime(0,stopTime+0.01);}if(nodes.osc){nodes.osc.stop(stopTime+0.02);nodes.osc.disconnect();}if(nodes.lfo){nodes.lfo.stop(stopTime+0.02);nodes.lfo.disconnect();}if(nodes.lfoGain){nodes.lfoGain.disconnect();}}catch(e){console.warn(`Error stopping nodes Ch${channelIndex}:`,e);}channelNodes[channelIndex]=null;channelPlayingData[channelIndex]={frequency:null,instrument:null};}

        // Updated to handle effects (vibrato)
        function playFrequency(channelIndex, frequency, instrumentType, volume, effect, startTime) {
             if (!audioContext || !masterGain || channelIndex < 0 || channelIndex >= NUM_CHANNELS) return;
             // Ensure previous nodes for this channel are stopped before creating new ones
             if (channelNodes[channelIndex]) {
                 // console.warn(`Ch${channelIndex}: Nodes exist before playFrequency call, stopping first.`); // Debug
                 stopChannelNodes(channelIndex, startTime); // Stop immediately before creating new
             }

             try {
                 // --- Create Main Oscillator ---
                 const osc = audioContext.createOscillator();
                 const mappedType = INSTRUMENT_MAP[instrumentType] || 'sine';
                 osc.type = mappedType;
                 // Set base frequency - this might be modulated by LFO
                 osc.frequency.setValueAtTime(frequency, startTime);

                 // --- Create Main Gain Node (Volume + Envelope) ---
                 const gain = audioContext.createGain();
                 gain.gain.setValueAtTime(0, startTime); // Start silent
                 gain.gain.linearRampToValueAtTime(volume, startTime + 0.01); // Quick attack

                 // --- Handle Effects ---
                 let lfo = null;
                 let lfoGain = null;

                 // Check for Vibrato command and valid parameters
                 if (effect && effect.command === 'V' && effect.param1 > 0 && effect.param2 >= 0) { // Allow 0 depth
                     const rate = effect.param1;
                     const depthSemitones = effect.param2;
                     // console.log(`Ch${channelIndex}: Applying Vibrato - Rate: ${rate}, Depth: ${depthSemitones}`); // Debug

                     // Calculate frequency deviation in Hz based on semitone depth
                     const freqRatio = Math.pow(2, depthSemitones / 12);
                     const deviationHz = frequency * (freqRatio - 1);

                     if (deviationHz >= 0) { // Allow zero deviation (effect off but nodes created)
                         lfo = audioContext.createOscillator();
                         lfo.frequency.setValueAtTime(rate, startTime); // Vibrato rate

                         lfoGain = audioContext.createGain();
                         lfoGain.gain.setValueAtTime(deviationHz, startTime); // Vibrato depth in Hz

                         lfo.connect(lfoGain);
                         lfoGain.connect(osc.frequency); // Modulate the frequency parameter

                         lfo.start(startTime); // Start LFO
                     } else {
                          console.warn(`Ch${channelIndex}: Invalid deviationHz (${deviationHz}) for vibrato.`);
                     }
                 }

                 // --- Connect Main Nodes ---
                 osc.connect(gain);
                 gain.connect(masterGain);

                 osc.start(startTime);

                 // --- Store references to all created nodes ---
                 channelNodes[channelIndex] = { osc, gain, lfo, lfoGain };

             } catch (e) {
                 console.error(`Error playing frequency Ch${channelIndex}:`, e);
                 showMessage(`Error Ch${channelIndex+1} sound`);
                 channelNodes[channelIndex] = null; // Clear nodes on error
             }
         }


        function startPlayback() { /* ... no change ... */ if(isPlaying)return;initAudio();if(!audioContext){showMessage("Audio Error: Cannot init AudioContext.");return;}if(audioContext.state==='suspended'){audioContext.resume();}isPlaying=true;currentPlayRow=focusPos.row;channelPlayingData=new Array(NUM_CHANNELS).fill({frequency:null,instrument:null});lastRowTime=audioContext.currentTime;PLAY_BUTTON.textContent='...';PLAY_BUTTON.disabled=true;STOP_BUTTON.disabled=false;console.log("Starting playback...");showMessage("Playing...");playStep();setTimeout(()=>{if(isPlaying)PLAY_BUTTON.textContent='Play';},100); }
        function stopPlayback() { /* ... no change ... */ if(!isPlaying)return;isPlaying=false;clearTimeout(playbackIntervalId);playbackIntervalId=null;const now=audioContext?audioContext.currentTime:0;for(let c=0;c<NUM_CHANNELS;c++){stopChannelNodes(c,now);}document.querySelectorAll('.playing-row').forEach(r=>r.classList.remove('playing-row'));PLAY_BUTTON.disabled=false;STOP_BUTTON.disabled=true;console.log("Playback stopped.");showMessage("Stopped."); }
        function getEffectiveTempo(row) { /* ... no change ... */ const tD=getEffectiveValue(row,0,'tempo');return tD||(parseFloat(BASE_TEMPO_INPUT.value)||120); }
        function getTickDurationSeconds(currentTempo) { /* ... no change ... */ const rPB=parseInt(ROWS_PER_BEAT_INPUT.value)||4;if(currentTempo<=0||rPB<=0)return 0.5;const bPS=currentTempo/60;const rPS=bPS*rPB;return 1.0/rPS; }


        // --- JSON Export ---
        function handleExportJson() { /* ... no change ... */ try{const jS=JSON.stringify(patternData,null,2);const b=new Blob([jS],{type:'application/json'});triggerDownload(b,"tracker_pattern.json");showMessage("Exported pattern data as JSON.");}catch(e){console.error("Error exporting JSON:",e);showMessage("Error exporting JSON.");} }
        function triggerDownload(blob, filename) { /* ... no change ... */ const u=URL.createObjectURL(blob);const a=document.createElement('a');document.body.appendChild(a);a.style.display='none';a.href=u;a.download=filename;a.click();window.URL.revokeObjectURL(u);a.remove(); }

        // --- WAV Export Logic ---
        // NOTE: Vibrato effect is NOT currently rendered in WAV export.
        async function renderPatternToBuffer() { /* ... no change ... */ showMessage("Rendering audio (Note: Vibrato effect NOT included in export)...");await new Promise(r=>setTimeout(r,10));let tS=0;const rD=[];const bT=parseFloat(BASE_TEMPO_INPUT.value)||120;let cT=bT;for(let r=0;r<NUM_ROWS;r++){const tDa=getEffectiveValue(r,0,'tempo');cT=tDa||cT;const tDS=getTickDurationSeconds(cT);if(tDS<=0){showMessage("Error: Invalid tempo/rows.");return null;}const tSa=Math.floor(tDS*EXPORT_SAMPLE_RATE);rD.push(tSa);tS+=tSa;}const aB=new Float32Array(tS).fill(0);let cSO=0;let rCLF=new Array(NUM_CHANNELS).fill(parseFloat(BASE_FREQ_INPUT.value)||440.0);let rCP=new Array(NUM_CHANNELS).fill(0);for(let r=0;r<NUM_ROWS;r++){const tSa=rD[r];const rSTS=cSO;for(let c=0;c<NUM_CHANNELS;c++){const nD=getEffectiveValue(r,c,'note');const i=getEffectiveValue(r,c,'inst');const v=getEffectiveValue(r,c,'vol');let cF=null;if(nD&&nD.inputString){const pN=parseNoteInputForRender(nD.inputString,c,rCLF[c]);cF=pN.frequency;if(cF!==null){rCLF[c]=cF;}}else if(nD&&nD.frequency){cF=nD.frequency;rCLF[c]=cF;}if(cF!==null&&cF>0&&v>0){const mI=INSTRUMENT_MAP[i]||'sine';const gen=WAVEFORM_GENERATORS[mI];if(gen){const nS=gen(cF,tSa,EXPORT_SAMPLE_RATE,v,rCP[c]);for(let i=0;i<tSa;i++){const bI=rSTS+i;if(bI<tS){aB[bI]+=nS.samples[i];}}rCP[c]=nS.endPhase;}else{rCP[c]=0;}}else{rCP[c]=0;}}cSO+=tSa;}let mA=0;for(let i=0;i<tS;i++)mA=Math.max(mA,Math.abs(aB[i]));if(mA>1.0){const s=1.0/mA;for(let i=0;i<tS;i++)aB[i]*=s;console.log(`Normalized: Peak ${mA.toFixed(3)}`);}else if(mA===0)console.log("Warning: Rendered buffer silent.");else console.log(`Peak: ${mA.toFixed(3)}`);return aB;}
        function parseNoteInputForRender(iS,cI,lF){ /* ... no change ... */ iS=iS.trim();if(!iS)return{frequency:null};if(/^\d+(\.\d+)?$/.test(iS)){const f=parseFloat(iS);return{frequency:f>0?f:null};}const rM=iS.match(/^(\d+)\s*:\s*(\d+)$/);if(rM){try{const n=parseInt(rM[1]),d=parseInt(rM[2]);if(d<=0||n<0)return{frequency:null};const b=lF||(parseFloat(BASE_FREQ_INPUT.value)||440.0);if(b<=0)return{frequency:null};const cF=b*n/d;return{frequency:cF>0?cF:null};}catch(e){return{frequency:null};}}return{frequency:null};}
        function encodeWav(samples, sampleRate, bitDepth) { /* ... no change ... */ const bPS=bitDepth/8,nC=1,bA=nC*bPS,bR=sampleRate*bA,dS=samples.length*bPS,cS=36+dS,bf=new ArrayBuffer(44+dS),v=new DataView(bf);function wS(o,s){for(let i=0;i<s.length;i++)v.setUint8(o+i,s.charCodeAt(i));}wS(0,'RIFF');v.setUint32(4,cS,true);wS(8,'WAVE');wS(12,'fmt ');v.setUint32(16,16,true);v.setUint16(20,1,true);v.setUint16(22,nC,true);v.setUint32(24,sampleRate,true);v.setUint32(28,bR,true);v.setUint16(32,bA,true);v.setUint16(34,bitDepth,true);wS(36,'data');v.setUint32(40,dS,true);let o=44;const m=Math.pow(2,bitDepth-1)-1;for(let i=0;i<samples.length;i++,o+=bPS){const s=Math.max(-1,Math.min(1,samples[i]));v.setInt16(o,s*m,true);}return new Blob([bf],{type:'audio/wav'}); }
        function triggerWavDownload(wavBlob, filename = "tracker_export.wav") { triggerDownload(wavBlob, filename); }
        async function handleExportWav() { /* ... no change ... */ EXPORT_WAV_BUTTON.disabled=true;EXPORT_WAV_BUTTON.textContent='Exporting...';try{const aB=await renderPatternToBuffer();if(aB&&aB.length>0){const wB=encodeWav(aB,EXPORT_SAMPLE_RATE,EXPORT_BIT_DEPTH);triggerWavDownload(wB);}else if(aB){showMessage("Export failed: Pattern silent.");}else{showMessage("Export failed rendering.");}}catch(e){console.error("Error WAV export:",e);showMessage("Export failed. See console.");}finally{EXPORT_WAV_BUTTON.disabled=false;EXPORT_WAV_BUTTON.textContent='Export WAV';} }
        function generateSine(f,dS,sR,a,sP=0){const b=new Float32Array(dS),w=2*Math.PI*f/sR;let p=sP;for(let i=0;i<dS;i++){b[i]=a*Math.sin(p);p+=w;}return{samples:b,endPhase:p%(2*Math.PI)};} function generateSquare(f,dS,sR,a,sP=0){const b=new Float32Array(dS),pS=sR/f,w=2*Math.PI*f/sR;let p=sP;for(let i=0;i<dS;i++){b[i]=a*(Math.sin(p)>=0?1:-1);p+=w;}return{samples:b,endPhase:p%(2*Math.PI)};} function generateSawtooth(f,dS,sR,a,sP=0){const b=new Float32Array(dS),pS=sR/f,w=2*Math.PI*f/sR;let p=sP/(2*Math.PI);for(let i=0;i<dS;i++){b[i]=a*(2*(p-Math.floor(0.5+p)));p+=(w/(2*Math.PI));}return{samples:b,endPhase:(p*2*Math.PI)%(2*Math.PI)};} function generateTriangle(f,dS,sR,a,sP=0){const b=new Float32Array(dS),pS=sR/f,w=2*Math.PI*f/sR;let p=sP;for(let i=0;i<dS;i++){b[i]=a*(2*Math.abs(2*(p/(2*Math.PI)-Math.floor(0.5+p/(2*Math.PI))))-1);p+=w;}return{samples:b,endPhase:p%(2*Math.PI)};}
        const WAVEFORM_GENERATORS = { 'sine': generateSine, 'square': generateSquare, 'sawtooth': generateSawtooth, 'triangle': generateTriangle };


        // --- Utility ---
        let messageTimeout = null;
        function showMessage(text, duration = 2500) { /* ... no change ... */ MESSAGE_BOX.textContent=text;MESSAGE_BOX.style.display='block';clearTimeout(messageTimeout);if(duration>0){messageTimeout=setTimeout(()=>{MESSAGE_BOX.style.display='none';},duration);} }

        // --- Initialization ---
        PLAY_BUTTON.addEventListener('click', startPlayback);
        STOP_BUTTON.addEventListener('click', stopPlayback);
        EXPORT_WAV_BUTTON.addEventListener('click', handleExportWav);
        EXPORT_JSON_BUTTON.addEventListener('click', handleExportJson);
        STOP_BUTTON.disabled = true;

        // Add listeners for base config changes
        BASE_FREQ_INPUT.addEventListener('change', () => { showMessage(`Base Frequency updated`); });
        BASE_TEMPO_INPUT.addEventListener('change', () => { showMessage(`Base Tempo updated`); });


        initializePatternData(); // Initializes pattern and captured values
        generateTrackerTable();
        console.log("Tracker initialized.");
        showMessage("Tracker Ready. F5 to Play/Stop.", 3000);

    </script>

</body>
</html>
